# 第一次过程报告

## 计算机1801 常开妍 20184449

### 一、工作内容

#### 第一次上机

1. 分工——语法分析、语义分析

   - 语法分析：递归子程序分析法
   - 语义分析：设计翻译文法，在语法分析过程中插入语动作，设想生成语法树数据结构，每个节点可以利用结构体存储大量信息。但是涉及到优化和目标代码生成部分的实现可能较为困难（由于在课程中没有学习过），所以选择去查找相关资料先做了解再与组员探讨。
2. 完善文法

   - 组长首先草拟了简易的类C语言文法，发给我们进行讨论和检查。由于要使用递归子程序分析法，所以我将文法进行了消除左递归操作，使其转换为了LL(1)文法。
3. 下一步工作计划

   - 确定语法树or四元式；
   - 设计翻译文法，在文法中插入语义动作；
   - 编写简单文法产生式的语法分析部分代码。

#### 第二次上机

1. 确定四元式

   - 在答疑过程中，听取张俐老师的建议，语义分析使用四元式进行存储。原因是语法树不需要在整个编译过程中显示体现出来，只在语法制导翻译过程中用到了语法树的思想，所以四元式相对而言节省了非必要的空间和时间浪费，相对直接、简单。

2. 与组员探讨接口

   - 与负责词法分析部分的同学提议设计包含扫描器的词法分析器Lexer，并探讨出了Token结构体中的具体成员信息，方便后续的调用。

   ```c++
   class Lexer {				//词法分析器
   public:
   	void init(string name);	//初始化扫描器
   	Token next_Token();		//产生一个Token,如果是标识符指向符号表，关键字指向关键字表，界符指向界符表，常量指向常量表
   private:
   	Recognizer rec;			//扫描器
   	string currentWord;		//当前读到的单词
   };
   ```

   ```c++
   class Token {		//Token
   public:
   	Token(char t, string c, int r);
   	Token();
   	void set(char t, string c, int r);
   	char type;		//单词的类型，如关键字，标识符，界符等
   	string content;	//这个token代表的单词内容
   	int row;		//显示代码所在行数，简单报错时使用
   };
   ```

   - 与负责优化和目标代码生成的同学共同探讨四元式QT的结构，除了操作符、操作数、结果变量外，还加入了基本块信息以及清空四元式的clear函数以便优化，其中操作数定义为token类型，能够包含变量类型、活跃信息等信息用于查表后填入四元式的相应位置，以便目标代码生成。

   ```c++
   struct QT
   {
   	string Operat;		//操作符
   	token opA;			//操作数1
   	token opB;			//操作数2
   	token res;			//中间变量
   	int block;			//基本块数
   	QT() { Operat = ""; opA.clear(); opB.clear(); res.clear(); }
   	QT(string Operatt, token opAt, token opBt, token rest) { Operat = Operatt; opA = opAt; opB = opBt; res = rest; }
   	void clear() { Operat = ""; opA.clear(); opB.clear(); res.clear(); }
   
   };
   ```

   ```c++
   struct token {
   	string name;
   	int type;	//单词类型：1常量2非临时变量3临时变量
   	bool active;	//活跃信息(目前只考虑单寄存器)
   	token() { name = ""; type = 0; active = false; }
   	token(string namet, int typet, bool activet) { name = namet; type = typet; active = activet; }
   	void clear() { name = ""; type = 0; active = false; }
   
   };
   ```

   - 与负责符号表的同学暂时没有深入探讨，因为涉及到四元式产生式函数的具体语义动作以及函数等等，只是大致了解语法分析过程中需要查表和填表，直接调用函数即可。

3. 编写代码——语法分析、生成四元式

   - 语法分析：目前阶段设想先实现简单的文法产生式，实现了常量声明、数值声明、赋值语句、逻辑表达式、算术表达式的递归子程序分析法。在语法分析过程，根据编写代码的可行性，适当修改了部分文法产生式，目前的不足之处在于没有涉及数组的相关分析。实现方法：将所有产生式的非终结符用英文翻译出来，设置为返回值为整型数据的函数，按照文法依次调用，若调用成功返回值为1，调用失败返回值为0。另外，还设计了一个报错函数Error()，可以显示错误在第几行。
   - 生成四元式：语法分析时顺便翻译了文法，暂时声明了一些用到的四元式产生式函数，但是还没有设计语义动作。

4. 下一步工作计划

   - 针对目前的简单文法生成四元式，为四元式产生式添加语义动作。终结符即运算对象的属性值暂存到语义栈中，遇到四元式生成函数则通过弹出栈顶、次栈顶元素生成四元式，存放在QT结构体中。

#### 第三次上机

1. 与组员探讨接口

   - 与负责符号表的同学探讨需要用到符号表的位置，逻辑表达式运算和赋值语句都需要查表和填表，了解了相关函数的功能和接口后，就可以编写具体的语义动作了。

2. 设计语义动作

   目前的的简单文法产生式中，只有逻辑运算表达式和赋值语句涉及到产生四元式，定义函数GEQ()和ASSI()并插入语义动作，下面是生成四元式过程中相关函数功能的设计描述。

   - 临时变量（操作）：在编写GEQ()函数过程中发现运算过程中临时变量是必要的，进入函数后需要首先查询四元式中的临时变量，如果没有需要按顺序生成。此过程中用到了vector向量和iterator迭代器以及string类中的find()成员函数进行查询，简化过程。
   - 操作栈模板函数mystack()：产生四元式的过程需要借助数据结构——栈，而由于操作对象类型繁多，于是设计了模板函数，其中涉及到与生成四元式相关的操作，都设置为了成员函数并分别进行了定义，方便后续的栈操作。
   - 比较操作对象类型函数CompareType()：我们涉及的类C语言的操作对象需是相同类型，无论是逻辑运算还是赋值，都需要首先判断操作对象的类型是否一致。于是定义了返回值是bool类型的CompareType()函数，专门用于判断次栈顶元素和栈顶元素是否相同，若不同则会报错：“类型不匹配”。
   - 逻辑运算函数resvalue()：在操作对象的类型判断正确后，需要根据逻辑运算符以及操作对象类型进行运算。设计了resvalue()函数进行逻辑运算，以字符串类型返回运算结果。这里涉及到了查询符号表的操作，需要明确操作符的类型type和次栈顶元素value_1和栈顶元素value_2的数值。采用枚举的方法，将我们所涉及的文法中每种数据类型情况都列举了出来。其中需要注意的是，每种类型的数值都需要通过stringToNum()模版函数将字符串形式转换成了其正确的数据类型进行运算。
   - 逻辑运算四元式产生函数GEQ()：通过调用上述函数，简化了函数内部的结构，在计算出表达式结果之后需要根据结果的类型填写符号表，最后进行弹栈等操作。
   - 赋值四元式产生函数ASSI()：该函数的难点在于查表和填表，因为各种常量变量的类型十分复杂，非全局变量、全局变量、非临时变量、临时变量等，因此需要多次的判断。首先要明确赋值符号=右侧的常量还是变量，再去判断是否为用户定义的全局变量，再根据栈顶元素的类型进行填表...最终生成四元式。其中需要注意的是整型常数的赋值问题，栈顶元素为常数需要通过to_string()函数将其转换为字符串，便于查表和填表。

3. 下一步工作计划

   - 与组员进行讨论，着手设计数组和函数的语法分析以及四元式生成部分。

### 二、遇到问题及解决方案

+ 文法：第一次设计的文法较为粗糙，消除左递归的过程中忽略了很多细节，尤其是对空的判断。我在第一次修改文法的时候，将实际的代码代入分析，再与组长进行探讨核实，花费了一些时间；第二次真正写到语法分析的时候发现，不仅要把中文用恰当的英语翻译出来填入文法做标记，还需要将合并到一起的某些大类细分为小类，如逻辑运算符就是典型的例子，目的是为了判断每一个运算符，生成对应的四元式。针对代码中判断功能重复的部分，会在时间允许的情况下进行优化。
+ 接口：在与组员探讨各部分的接口时，花费了很长时间。所谓万事开头难，如果不提前商议好，可能导致后续的优化、目标代码生成的改动很大。在仔细研究了后续需要用的各类信息后，才敲定了某些结构体的成员。可见团队成员之间多多沟通交流可以避免很多不必要的工作。
+ 实践：语法分析、语义分析我们都选用了较为简单的实现方式，但是还是涉及到了很多C++语言编程的基础知识。由于之前的学习只停留在了书本，实践的相对较少，用到的知识体系也不完善。在本次课设中，在有了一定的想法之后查阅了很多相关资料，也会时常向组长寻求帮助，听取他的建议利用C++的某些便利条件简化实现过程。目前代码还没有运行测试，后续会与词法分析器、符号表连接起来，发现问题尽快调试。

### 三、心得体会

+ 小学期时间紧任务重，老师们采取汇报进度、阶段验收的方式虽然带给了我压力，但是我认为对我这种习惯拖延难题的人来说也是一种动力。为了完成任务，不得不花费心思和精力，而在这种“不得不”的促使下，我的确学到了很多：比如团队合作需要多交流沟通；更加了解C++语言的编程的便利；最重要的是不要畏惧困难等待别人的帮助等等。最后感谢编译原理的老师们的用心良苦，助教学长学姐的认真负责，我也会和我的小组成员好好配合，尽力去做好这次的课设。
